# PCILeech Firmware Generator

[![CI](https://github.com/ramseymcgrath/PCILeechFWGenerator/workflows/CI/badge.svg)](https://github.com/ramseymcgrath/PCILeechFWGenerator/actions)
[![codecov](https://codecov.io/gh/ramseymcgrath/PCILeechFWGenerator/branch/main/graph/badge.svg)](https://codecov.io/gh/ramseymcgrath/PCILeechFWGenerator)
![](https://dcbadge.limes.pink/api/shield/429866199833247744)

Generate spoofed PCIe DMA firmware from real donor hardware with a single command. The workflow rips the donor's configuration space, builds a personalized FPGA bit‑stream locally by default (or optionally in an isolated container), and (optionally) flashes your DMA card over USB‑JTAG.

---

## ✨ Features

- **🎯 Donor Hardware Analysis**: Extract real PCIe device configurations and register maps
- **💾 Full 4 KB Config-Space Shadow**: Complete configuration space emulation with overlay RAM
- **🔄 MSI-X Table Replication**: Exact replication of MSI-X tables from donor devices
- **✂️ Capability Pruning**: Selective modification of capabilities that can't be faithfully emulated
- **🎲 Deterministic Variance Seeding**: Consistent hardware variance based on device serial number
- **📊 Behavioral Profiling**: Capture dynamic device behavior patterns for enhanced realism
- **🔧 Manufacturing Variance Simulation**: Add realistic timing jitter and parameter variations
- **⚡ Advanced SystemVerilog Generation**: Comprehensive PCIe device controller with modular architecture
- **🐳 Automated Build Pipeline**: Containerized synthesis and bit-stream generation
- **🔌 USB-JTAG Flashing**: Direct firmware deployment to DMA boards
- **🖥️ Interactive TUI**: Modern text-based interface with real-time monitoring and guided workflows
- **🔁Regular Updating**: Users can update their own features and even swap between presets.

## Read this first

### Donor info

The firmware generated by this tool contains real info pulled from a local PCIE device. The device is unbound from its current driver and bound to vfio-pci inside of a container. Inside the container we scrape the identifiers, config space, BAR info and interrupts from the card, validate them and write templates that can be added to a pcileech card firmware. For more in-depth info see [Device Cloning](#device-cloning)

> [!WARNING]
> This tool is designed to work with real hardware and there is _no_ fallback or placeholder configuration. It won't generate realistic or secure firmware without a donor card.

### About the code

The TCL is mostly templated out using Jinja in the templates dir. Python does most of the template generation and runs in a container using podman by default. It usually autodiscovers Vivado for the final TCL compilation but you can also pass in the TCL yourself. The template generation is pretty quick but depending on your PC it might take a while to compile.

---

I tried to align all of the python versions and paths up to be as reliable as possible, and podman helps, but you may need to edit some paths if you see issues. Please PR things back into this repo if its something that will help the community.
This codebase is modular enough to be imported into other code bases as well.

### Supported Donor Devices

It'll best effort clone any pcie device you give it, but generally linux-compatible network/storage/media cards that work best. I don't recommend using the unit test default values outside of local testing.
Please avoid adding those UUIDs when making tickets.

### Goals

This tool is designed to make DMA firmware transparent. A pcileech device can access all of your PCs memory and you should know whats running on it, and what it's limits are.
This tool also provides a replacement for huge pools of firmware with identical IDs by making it easy to use your own donor card.

## 🚀 Quick Start

The best way to start with the latest code is to clone and run from this repo directly. However pip can also be used.

### Pip Installation

```bash
# Basic installation
pip install pcileechfwgenerator

# With TUI support (recommended)
pip install pcileechfwgenerator[tui]

# Get sudo wrapper scripts
wget https://raw.githubusercontent.com/ramseymcgrath/PCILeechFWGenerator/refs/heads/main/install-sudo-wrapper.sh

# Install sudo wrapper scripts (recommended for TUI and build commands)
./install-sudo-wrapper.sh

# Load required kernel modules
sudo modprobe vfio
sudo modprobe vfio-pci
```

If you have pip issues, it's usually easiest to just run from the repo. Make sure to install the python requirements.

### Other Requirements

Install Podman with your package manager. **Please just use podman!** Normal docker isn't able to mount the pcie devices correctly and you'll run into issues.

### Usage

#### Package Installation Commands

After pip installation, use these commands:

```bash
# TUI interface (recommended)
pcileech-tui

# CLI interface
pcileech-generate build

# Build-only interface
pcileech-build

# With sudo wrappers (if installed)
pcileech-tui-sudo
pcileech-build-sudo
```

#### Repository Development Usage

This can all be run from a venv. Ubuntu especially likes to manage the default python and some of the packages are way too old, and a venv is way easier.

```bash
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt

# CLI interface
# NOTE: use -E to preserve your paths
sudo -E python3 generate.py

# TUI interface
sudo -E python3 -m src.tui_cli

# Alternative TUI entry point
sudo -E python3 src/tui/main.py
```

Use the prompts to select your donor device and target FPGA.

### Entry Points Summary

The tool provides multiple entry points depending on your use case:

| Command | Purpose | Best For |
|---------|---------|----------|
| [`pcileech-tui`](src/tui_cli.py) | Interactive TUI interface | First-time users, guided workflows |
| [`pcileech-generate`](src/generate_cli.py) | Main CLI with build/flash commands | Scripting, automation |
| [`pcileech-build`](src/build_cli.py) | Build-focused interface | CI/CD, batch processing |
| [`generate.py`](generate.py) | Legacy entry point | Development, repository usage |

> [!WARNING]
> Careful with on-board devices like audio cards and graphics cards. The vfio process can sometimes lock the whole southside bus up and your PC will reboot.

### Device Suitability Indicators

In the TUI, devices are evaluated for firmware generation compatibility:

| Indicator | Meaning |
|-----------|---------|
| ✅ | **Suitable**: Device is compatible and not bound to a driver |
| ⚠️ | **Suitable with Warning**: Device is compatible but bound to a driver |
| ❌ | **Not Suitable**: Device is not compatible for firmware generation |

A device is considered suitable when its suitability score is ≥ 0.7 and it has no compatibility issues.

> [!NOTE]
> Your device might still work even though it has an ❌. The TUI should usually explain why it thinks it isn't suitable but sometimes it's wrong

## 📋 Requirements

### Software

This is primarily tested in Linux, with some fiddling you could probably get it to work on Windows too.

| Tool | Why you need it | Install |
|------|----------------|---------|
| Vivado Studio | Synthesis & bit‑stream generation | Download from Xilinx (any 2022.2+ release) |
| Podman | Rootless container runtime for the build sandbox | See installation instructions below |
| Python ≥ 3.9 | Host‑side orchestrator ([`generate.py`](generate.py)) | Distro package (python3) |
| λConcept usbloader | USB flashing utility for Screamer‑class boards | See installation instructions below |
| pciutils, usbutils | lspci / lsusb helpers | Available in most Linux distributions |

> [!WARNING]
> Never build firmware on the same operating system you plan to run the attack from. Use a separate Linux box.

### Hardware

| Component | Notes |
|-----------|-------|
| Donor PCIe card | Any inexpensive NIC, sound, or capture card works. One donor → one firmware. Destroy or quarantine the donor after extraction. |
| DMA board | Supported boards: pcileech_75t484_x1, pcileech_35t325_x4, pcileech_100t484_x1. Must expose the USB‑JTAG port. |

**TUI Features:**

- 🖥️ **Visual device browser** with enhanced PCIe device information
- ⚙️ **Guided configuration** with validation and profile management
- 📊 **Real-time build monitoring** with progress tracking and resource usage
- 🔍 **Intelligent error guidance** with suggested fixes
- 📡 **System status monitoring** for Podman, Vivado, USB devices, and more

See [`docs/TUI_README.md`](docs/TUI_README.md) for detailed TUI documentation.

## 🔌 Flashing the DMA Board

> **Note:** These steps can run on the same machine or a different PC.

1. Power down, install the DMA card, and remove the donor.

2. Connect the USB‑JTAG port.

3. Flash using one of these methods:

```bash
# Using the CLI flash command
pcileech-generate flash output/firmware.bin --board pcileech_75t484_x1

# Using the build CLI
pcileech-build flash output/firmware.bin --board pcileech_75t484_x1

# Using usbloader directly (if available)
usbloader -f output/firmware.bin      # auto‑detects Screamer VID:PID 1d50:6130
```

If multiple DMA boards are attached, add `--vidpid <vid:pid>` to usbloader.

## 🚀 Advanced Features

### Full 4 KB Config-Space Shadow

The configuration space shadow BRAM implementation provides a complete 4 KB PCI Express configuration space in block RAM (BRAM) on the FPGA. This is a critical component for PCIe device emulation, as it allows the PCILeech firmware to accurately respond to configuration space accesses from the host system.

**Key Capabilities:**

- **Complete Configuration Space**: Full 4 KB configuration space shadow in BRAM
- **Dual-Port Access**: Simultaneous read/write operations for improved performance
- **Overlay RAM**: Dedicated storage for writable fields (Command/Status registers)
- **Donor Initialization**: Automatic initialization from donor device configuration data
- **PCIe Compatibility**: Little-endian format compatible with PCIe specification

**Integration Benefits:**

- **Enhanced Realism**: Complete configuration space emulation for better device mimicry
- **Improved Compatibility**: Support for extended capabilities and configuration registers
- **Flexible Access**: Proper handling of read-only and read-write fields
- **Seamless Integration**: Works with MSI-X table replication and capability pruning

For more details, see [CONFIG_SPACE_SHADOW.md](docs/CONFIG_SPACE_SHADOW.md).

### MSI-X Table Replication

The donor's MSI-X table is cloned and automatically replicated in the generated firmware.

**Key Capabilities:**

- **Automatic Parsing**: Extract MSI-X capability structure from donor configuration space
- **BAR Integration**: Seamless integration with the BAR controller for memory-mapped access
- **Enhanced Compatibility**: Support for devices that rely on MSI-X interrupts
- **Improved Performance**: Efficient interrupt handling for high-performance devices
- **Realistic Behavior**: Accurate emulation of MSI-X interrupt delivery and masking
- **Flexible Configuration**: Support for different table sizes and configurations

For more details, see [MSIX_TABLE_REPLICATION.md](docs/MSIX_TABLE_REPLICATION.md).

### Variance Seeding

The deterministic variance seeding feature ensures that two builds of the same donor device at the same commit fall in the same timing band. This *means it will have*  consistent behavior across builds using the same device. But firmware will be unique 

**Key Capabilities:**

- **Deterministic Seed Generation**: Generate consistent seeds based on device serial number (DSN) and build revision
- **Consistent Variance**: Same donor device and build revision produce identical variance parameters
- **Device-Specific Variance**: Different donor devices produce different variance parameters
- **Reproducible Builds**: Consistent behavior across builds of the same donor device
- **Enhanced Realism**: Realistic hardware variance that's unique to each donor device
- **Reduced Detection Risk**: Variance parameters that match the donor device's characteristics
- **Seamless Integration**: Works with manufacturing variance simulation and behavioral profiling

For more details, see [INTEGRATED_FEATURES.md](docs/INTEGRATED_FEATURES.md).

### Advanced SystemVerilog Generation

Templating is used for all verilog output for ease of use and consistency. All PCILeech files are pulled directly from the source unmodified.

**Architecture Components:**

- **Modular Design**: Specialized components for power, error handling, and performance monitoring
- **Multiple Clock Domains**: Proper clock domain crossing with variance-aware timing
- **Device-Specific Logic**: Optimizations for Network, Storage, Graphics, and Audio devices
- **Comprehensive Integration**: All components work together seamlessly

**Error Handling & Recovery:**

- **Recovery Mechanisms**: Automatic error recovery and link retraining
- **Error Logging**: Detailed error tracking and reporting

**Performance Monitoring:**

- **Hardware Counters**: Transaction, bandwidth, and latency monitoring
- **Device-Specific Metrics**: Tailored counters for different device types
- **Real-time Monitoring**: Live performance data collection
- **Threshold-based Alerts**: Configurable performance thresholds

**Device-Specific Optimizations:**

- **Network Devices**: Multi-queue support, interrupt coalescing, checksum offload
- **Storage Devices**: Command queuing, wear leveling, power loss protection
- **Graphics Devices**: Memory bandwidth optimization, display timing
- **Audio Devices**: Low-latency processing, sample rate conversion

### Command-Line Options

**Main Commands:**

- `pcileech-generate build`: Main build command with guided device selection
- `pcileech-tui`: Interactive TUI interface (recommended)
- `pcileech-build`: Build-focused CLI interface

**Build Options:**

- `--bdf <BDF>`: Specify PCIe device Bus:Device.Function (e.g., 0000:01:00.0)
- `--board <BOARD>`: Target board (pcileech_75t484_x1, pcileech_35t325_x4, pcileech_100t484_x1)
- `--device-type <TYPE>`: Device type (network, storage, graphics, audio, generic)
- `--advanced-sv`: Enable advanced SystemVerilog generation
- `--disable-variance`: Disable manufacturing variance simulation
- `--enable-behavior-profiling`: Enable dynamic behavior profiling
- `--profile-duration <SECONDS>`: Profiling duration (default: 30.0)

**Flash Options:**

- `pcileech-generate flash <FIRMWARE> --board <BOARD>`: Flash firmware to board

## 🧹 Cleanup & Safety

- **Rebind the donor**: Use the TUI or CLI to rebind the donor back to its original driver if you keep it around.
- **Keep firmware private**: Generated firmware contains real identifiers from the donor device.
- **Privilege requirements**: Advanced features require appropriate privileges for hardware access (use sudo wrappers).
- **Hardware conflicts**: Don't try to use a donor card and FPGA simultaneously on the same system.
- **Container cleanup**: Remove build containers after use: `podman rmi pcileechfwgenerator:latest`

## Device Cloning

The device cloning process creates an FPGA-based replica of a PCIe device through systematic hardware analysis and template generation. This section details the multi-stage process and error handling mechanisms.

### Prerequisites and System Requirements

Before cloning begins, the system must meet specific requirements:

- **IOMMU Support**: Intel VT-d or AMD-Vi must be enabled in BIOS/UEFI
- **Kernel Configuration**: VFIO modules loaded (`vfio`, `vfio-pci`, `vfio_iommu_type1`)
- **Root Privileges**: Required for VFIO device binding operations
- **Fallback Mode**: For testing environments without IOMMU, use `iommu=pt` or `vfio.enable_unsafe_noiommu_mode=1`

### Stage 1: VFIO Device Acquisition

The generator establishes exclusive control over the target PCIe device through Linux VFIO:

1. **IOMMU Group Discovery**: Identifies all devices sharing the same IOMMU group as the target BDF (e.g., `0000:01:00.0`)
2. **Driver Unbinding**: Safely unbinds existing kernel drivers from all group members
3. **VFIO Binding**: Rebinds devices to the `vfio-pci` driver for userspace access
4. **Handle Creation**: Establishes `/dev/vfio/<group>` interface for safe device interaction

**Error Handling**:

- **IOMMU Unavailable**: Falls back to heuristic size estimation (requires explicit enablement)
- **Driver Conflicts**: Automatically handles in-use drivers with graceful fallback
- **Permission Errors**: Provides clear diagnostic messages for privilege escalation

### Stage 2: Configuration Space Analysis

The generator performs comprehensive configuration space extraction:

#### Standard PCI Header (0x00-0xFF)

- **Device Identity**: Vendor ID, Device ID, Subsystem IDs, Class Code, Revision
- **Command/Status**: Capability flags, error status, device state
- **BAR Registers**: Base Address Registers 0-5 with size and type information
- **Interrupt Configuration**: Legacy INTx pin assignments

#### Extended Configuration Space (0x100-0xFFF)

- **Capability Structures**: MSI/MSI-X, Power Management, PCIe-specific capabilities
- **Vendor-Specific**: Custom capability blocks preserved byte-for-byte
- **Advanced Features**: AER, VC, PASID, and other modern PCIe capabilities

**Validation and Security**:

- **Checksum Generation**: SHA-256 hash of configuration space prevents generic firmware
- **Signature Verification**: Ensures unique firmware per donor device
- **Sanitization**: Removes potentially sensitive vendor-specific data when requested

### Stage 3: BAR Discovery and Memory Mapping

Systematic analysis of Base Address Registers determines memory layout:

```
For each BAR index (0-5):
├── Issue VFIO_DEVICE_GET_REGION_INFO ioctl
├── Extract: size, read/write permissions, mmap capability
├── Filter: Ignore I/O ports and zero-sized regions
├── Record: All valid MMIO BARs with metadata
└── Select: Largest MMIO BAR as primary window
```

**Advanced BAR Handling**:

- **64-bit BARs**: Properly handles paired 32-bit registers
- **Prefetchable Memory**: Preserves caching hints and optimization flags
- **Size Validation**: Ensures BAR sizes are power-of-2 aligned
- **Conflict Resolution**: Handles overlapping or invalid BAR configurations

**Fallback Mechanisms**:

- **Heuristic Sizing**: When VFIO fails, estimates BAR sizes from register patterns
- **Conservative Defaults**: Uses safe minimum sizes for critical BARs
- **Manual Override**: Allows explicit BAR configuration via command-line parameters

### Stage 4: Interrupt Architecture Analysis

The generator determines optimal interrupt emulation strategy:

#### Priority Order (Highest to Lowest)

1. **MSI-X**: Multi-vector message signaled interrupts
   - Validates table size > 0
   - Preserves vector count and table structure
   - Maps interrupt vectors to FPGA resources

2. **MSI**: Single-vector message signaled interrupts
   - Fallback when MSI-X unavailable
   - Simpler implementation with single interrupt line

3. **Legacy INTx**: Pin-based interrupts
   - Last resort for older devices
   - Emulates traditional interrupt sharing

**Capability Validation**:

- **Table Size Verification**: Ensures MSI-X table is properly sized
- **Vector Count Limits**: Respects hardware and software constraints
- **Interrupt Routing**: Validates interrupt pin assignments

### Stage 5: Template Context Generation

All extracted data is consolidated into a comprehensive template context:

#### Core Components

- **Device Identity**: Complete PCI configuration header
- **Memory Layout**: BAR map with sizes, types, and access patterns
- **Interrupt Configuration**: Selected interrupt mechanism with parameters
- **Timing Parameters**: Clock domains, reset sequences, power states
- **Feature Flags**: DMA capabilities, error handling, debug interfaces

#### Validation Pipeline

```
Context Validation:
├── Required Fields Check
│   ├── Non-zero Vendor ID
│   ├── Valid Device Class
│   └── Usable MMIO BAR present
├── Consistency Verification
│   ├── BAR size alignment
│   ├── Capability chain integrity
│   └── Interrupt configuration validity
└── Security Validation
    ├── Signature uniqueness
    ├── No default/generic patterns
    └── Sanitized vendor data
```

**Error Recovery**:

- **Missing BARs**: Provides synthetic minimal BAR configuration
- **Invalid Capabilities**: Gracefully degrades to simpler interrupt modes
- **Corrupted Data**: Attempts repair or fails with detailed diagnostics

### Stage 6: Firmware Generation

The validated context drives the Jinja2/SystemVerilog template engine:

#### Output Artifacts

- **FPGA Bitstream**: Device-specific `.bit` or `.bin` file
- **Configuration Headers**: C/C++ headers for host software integration
- **JSON Metadata**: Machine-readable device description
- **Build Reports**: Synthesis timing, resource utilization, verification results

#### Quality Assurance

- **Template Validation**: Ensures generated Verilog is syntactically correct
- **Resource Estimation**: Predicts FPGA utilization before synthesis
- **Timing Analysis**: Validates clock domain crossings and setup/hold times

### Quick Start Command

```bash
# Enable IOMMU and run generator
sudo python3 generate.py build --donor 0000:01:00.0 --board pcileech_35t325_x4
```

## Firmware Uniqueness and Authenticity

The generated firmware achieves hardware-level authenticity through comprehensive device replication while maintaining a stable, maintainable core architecture.

### Cloned Device Characteristics

#### Exact Hardware Replication

The firmware replicates every aspect visible to system software:

**Configuration Space Fidelity**:

- **Standard Header**: Complete 256-byte PCI configuration header
- **Extended Capabilities**: All capability blocks (MSI/MSI-X, PM, PCIe, vendor-specific)
- **Device Identity**: Vendor ID, Device ID, Subsystem IDs, Class Code, Revision
- **Memory Layout**: BAR sizes, types, prefetchability flags, alignment requirements
- **Power Management**: P-states, D-states, wake capabilities, power budgets

**Address Space Mapping**:

- **BAR Decode Logic**: Synthesized to match original device's address map exactly
- **Memory Apertures**: Identical size, alignment, and access characteristics
- **I/O Space**: Preserved for devices requiring port-based access
- **Configuration Registers**: Byte-perfect replica of all readable registers

**System Integration**:

- **Interrupt Behavior**: MSI/MSI-X vector counts, table structures, delivery modes
- **DMA Capabilities**: Address width, coherency domains, IOMMU compatibility
- **Error Handling**: AER capabilities, error injection, recovery mechanisms
- **Hot-plug Support**: Surprise removal, attention indicators, power control

#### Detection Resistance

The firmware is designed to be indistinguishable from original hardware:

**Software Compatibility**:

- **Driver Binding**: Original device drivers load and function normally
- **OS Recognition**: [`lspci`](README.md:365), Device Manager, and system profilers show identical information
- **Diagnostic Tools**: Hardware scanners, benchmarks, and validation suites pass
- **Security Software**: Anti-tampering and hardware verification systems satisfied

**Cryptographic Uniqueness**:

- **Bitstream Signatures**: Each donor produces a unique FPGA configuration
- **ROM Content Hashing**: Configuration data ripples through synthesis, changing timing
- **Build Fingerprints**: Compilation timestamps and tool versions embedded
- **Entropy Sources**: Hardware-specific variations preserved in generated logic

### Stable Core Architecture

While device-specific characteristics change, the underlying infrastructure remains consistent:

#### Generic Hardware Components

**Data Path Elements** (unchanged across builds):

- **AXI4/Avalon Bridges**: Standard bus protocol translation
- **DMA Engines**: Configurable scatter-gather, descriptor management
- **Memory Controllers**: FIFO management, buffer allocation, flow control
- **Clock Management**: PLL configuration, domain crossing, reset distribution

**Debug and Monitoring Infrastructure**:

- **UART Interface**: Serial console for runtime diagnostics
- **JTAG Access**: Boundary scan, internal signal probing
- **Performance Counters**: Bandwidth monitoring, error statistics, latency measurement
- **CSR Map**: Control and status register interface for configuration

**System Services**:

- **Error Detection**: Parity checking, ECC, protocol violation detection
- **Power Management**: Clock gating, voltage scaling, thermal monitoring
- **Security Features**: Access control, encryption engines, secure boot

#### Parameterized Design Benefits

**Predictable Characteristics**:

- **Timing Closure**: Consistent setup/hold margins across device types
- **Resource Utilization**: Stable LUT, BRAM, and DSP usage patterns
- **Power Consumption**: Predictable static and dynamic power profiles
- **Thermal Behavior**: Consistent heat generation and dissipation

**Maintainability Advantages**:

- **Code Reuse**: Core modules shared across all device types
- **Testing Strategy**: Common test benches and verification environments
- **Documentation**: Stable API and interface specifications
- **Debugging**: Familiar signal names and debug interfaces

**Performance Optimization**:

- **Pipeline Depth**: Optimized for target clock frequencies
- **Memory Bandwidth**: Efficient utilization of available FPGA memory
- **Latency Characteristics**: Predictable response times for critical operations
- **Throughput Scaling**: Linear performance scaling with resource allocation

### Security and Research Applications

The firmware's authenticity makes it suitable for advanced security research:

**Red Team Operations**:

- **Hardware Implants**: Undetectable device substitution
- **Supply Chain Testing**: Verification of hardware authenticity measures
- **Driver Exploitation**: Testing device driver security with controlled hardware
- **Firmware Analysis**: Safe environment for reverse engineering and vulnerability research

**Blue Team Defense**:

- **Detection Algorithm Development**: Training datasets for hardware anomaly detection
- **Forensic Analysis**: Understanding attacker techniques and signatures
- **Incident Response**: Controlled reproduction of hardware-based attacks
- **Security Validation**: Testing hardware security measures and countermeasures

**Academic Research**:

- **Hardware Security**: Novel attack and defense mechanism development
- **System Architecture**: PCIe protocol research and optimization
- **Performance Analysis**: Benchmarking and characterization studies
- **Verification Methods**: Formal verification of hardware designs

The combination of perfect device replication and stable core architecture provides researchers with a powerful platform that maintains authenticity while offering the flexibility and observability needed for advanced security research and development.

## ⚠️ Disclaimer

This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software. The firmware generation is best effort and you should always validate it before use.

## 📦 Development & Contributing

For development setup instructions, please see [`docs/DEVELOPMENT.md`](docs/DEVELOPMENT.md).

### Contributing

We welcome contributions! Please see [`CONTRIBUTING.md`](CONTRIBUTING.md) for detailed guidelines.

**Quick Start:**

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Add tests for new functionality
5. Run the test suite (`pytest`)
6. Commit your changes (`git commit -m 'feat: add amazing feature'`)
7. Push to the branch (`git push origin feature/amazing-feature`)
8. Open a Pull Request

### Release Process

For maintainers releasing new versions:

```bash
# Automated release (recommended)
python scripts/release.py minor --release-notes "Add new TUI features and improvements"

# Manual release
python -m build
twine upload dist/*

# Test package installation
pip install --index-url https://test.pypi.org/simple/ pcileechfwgenerator[tui]
```

## 📚 Documentation

- **[Build System Architecture](docs/BUILD_SYSTEM_ARCHITECTURE.md)**: Entry points, build flow, and troubleshooting guide
- **[TUI Documentation](docs/TUI_README.md)**: Detailed TUI interface guide
- **[Manual Donor Dump Guide](docs/MANUAL_DONOR_DUMP.md)**: Step-by-step guide for manually generating donor dumps
- **[Contributing Guide](CONTRIBUTING.md)**: Development and contribution guidelines
- **[Changelog](CHANGELOG.md)**: Version history and release notes

## 🔧 Troubleshooting

### Common Issues

**Installation Problems:**
```bash
# If pip installation fails
pip install --upgrade pip setuptools wheel
pip install pcileechfwgenerator[tui]

# For development installation issues
pip install -e .[dev]
```

**TUI Not Starting:**

```bash
# Check TUI dependencies
python -c "import textual; print('TUI dependencies OK')"

# Install TUI dependencies manually
pip install textual rich psutil watchdog

# Try using the sudo wrapper
pcileech-tui-sudo

# Or run with preserved environment
sudo -E pcileech-tui
```

**Permission Issues:**

```bash
# Ensure proper permissions for PCIe operations
sudo usermod -a -G vfio $USER
sudo usermod -a -G dialout $USER  # For USB-JTAG access

# Load required kernel modules
sudo modprobe vfio
sudo modprobe vfio-pci
```

**Command Not Found:**

```bash
# If pcileech-* commands are not found after pip install
pip install --force-reinstall pcileechfwgenerator[tui]

# Or use the sudo wrappers
./install-sudo-wrapper.sh
pcileech-tui-sudo
```

**Container Issues:**

```bash
# Check Podman installation
podman --version

# Verify rootless setup
podman info | grep rootless

# Build container manually
podman build -t pcileechfwgenerator:latest -f Containerfile .

# Test container dependencies
podman run --rm pcileechfwgenerator:latest python3 -c "import psutil, pydantic; print('Dependencies OK')"

# Check container file structure
podman run --rm pcileechfwgenerator:latest ls -la /app/

# Test with required capabilities
podman run --rm --cap-add=SYS_RAWIO --cap-add=SYS_ADMIN pcileechfwgenerator:latest echo "Capability test passed"

# Debug container build issues
podman run --rm -it pcileechfwgenerator:latest /bin/bash
```

**Donor Dump Issues:**

```bash
# If donor_dump module fails to build or load
# See the Manual Donor Dump Guide for step-by-step instructions:
# docs/MANUAL_DONOR_DUMP.md

# Build the kernel module manually
cd src/donor_dump
make clean && make

# Load the module manually (replace BDF with your device)
sudo insmod donor_dump.ko bdf=0000:03:00.0
cat /proc/donor_dump > donor_info.txt
sudo rmmod donor_dump

# Check kernel module dependencies
modinfo src/donor_dump/donor_dump.ko
```

### Getting Help

- **GitHub Issues**: [Report bugs or request features](https://github.com/ramseymcgrath/PCILeechFWGenerator/issues)
- **GitHub Discussions**: [Community support](https://github.com/ramseymcgrath/PCILeechFWGenerator/discussions)
- **Documentation**: Check the docs/ directory for detailed guides

## 🏆 Acknowledgments

- **Xilinx/AMD**: For Vivado synthesis tools
- **Textual**: For the modern TUI framework
- **PCILeech Community**: For feedback and contributions

## 📄 License

This project is licensed under the Apache License - see the [LICENSE](LICENSE) file for details.

## ⚠️ Legal Notice

*AGAIN* This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.

**Security Considerations:**

- Never build firmware on systems used for production or sensitive operations
- Use isolated build environments (Seperate dedicated hardware)
- Keep generated firmware private and secure
- Follow responsible disclosure practices for any security research
- Use the SECURITY.md template to raise security concerns

---
